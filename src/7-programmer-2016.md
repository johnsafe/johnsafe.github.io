## Alan Kay 谈 OO 和 FP



译/王江平

### 理解“对象”的历程
关于“对象”（object）的理解，我经历了几个不同阶段。

第一阶段是50年前，在 ARPA 研究生院的开始几周，我的几种专业背景，数学、分子生物学、系统和程序设计等，与 Sketchpad、Simula 和 ARPAnet 这些东西产生了碰撞。这使我观察到，既然一台计算机可以分解成多台虚拟计算机，相互间持续通信，于是你便可以：

1. 完全保留表达式的威力；

2. 随时为任何可建模的东西建模；

3. 无限地伸缩，而不限于已有的分解计算机的方式。

我喜欢这些。分时运行的“进程”已是这种虚拟机的体现，但因为开销太大还缺少实际的通用性（那就寻找方法消除这些开销……）。

尽管可以为任何事物（包括数据结构）建模，对我来说这还远远不够。真正了不起的是为极端的可伸缩性需求提供松耦合的封装和消息机制（以一种类似生物和生态系统的方式）。

第二个阶段包括在“Lisp 世界”中掺入 Lisp 本身，McCarthy 关于机器人和时态逻辑的思想，在 ARPA（尤其是在 MIT）进行的 AI 工作，以及 Carl Hewitt 的 PLANNER 语言。有一种思想：对象可以像服务器一样，且可以是面向目标的，使用 PLANNER 类型的目标作为接口语言。

第三阶段是 Parc 的一系列 Smalltalks，试图在 Parc 的 Alto 系统（128K内存，一半用于显示设备）所能实现的和未来必然需要的功能之间寻找一种实用的平衡。这项工作是与 Dan Ingalls 和组里其他一些天才的同事合作完成的。理想主义的小宇宙一直让我不爽，但从实用角度结果不错。

第四阶段（也是在 Parc）是重新深入探讨时态逻辑和“世界线”（world-line）思想（后面细说）。

第五阶段是再次严肃地思考可伸缩性并重新审视“协作语言”（比如Gelernter的Linda），将它们看作以通用的发布和描述方式进行描述匹配，从而实现松耦合的一种方法。我仍然喜欢这种思想，并希望看它发展到对象可以真正“协商意义”的程度。

### McCarthy 的时态逻辑：“时间中的真正函数” 

我对这一切的思考方式大部分都可追溯到上世纪50年代的 John McCarthy。John 是一位出色的数学家和逻辑学家。他希望自己能做严密一致的逻辑推理——同时希望他的程序和机器人也能做到。机器人是个关键：因为他想让机器人有时在费城，有时在纽约。按常规逻辑这会有问题，然而 John 针对“事实”成立时能表现“时帧”（time frame）的所有事实额外添加了一个参数，从而修正了这一问题。这就创建了一种简单的时态逻辑，将“事实集合”显现为世界线的层层堆栈。

这很容易泛化为“变量”、“数据”、“对象”……的世界线。从个体角度来看，值的“历史”替换了“值”，从系统角度来看，整个系统被表示为每当系统处于两次计算之间时它所处的稳定状态。Simula 后来采用了这一思想的一个弱化但却实用的版本。

应当提一下 Christopher Strachey（编者注：1916年－1965年，生于英国英格兰伦敦汉普斯敦，计算机科学家。他是指称语义最早的提出者之一，也是编程语言设计的先驱，发展了编程语言 CPL）——Lisp 和 McCarthy 的伟大粉丝，他认识到通过始终使用（来自前一时帧的）旧值来产生新值并安装在新的时帧中，很多种编程模型都可以统一起来且更加安全。认识到这一点是因为他首先观察到 Lisp 中“尾递归”是多么干净利落，然后又看到这样的尾递归写成某种循环的形式更易理解：循环中包含类似赋值的语句，其中右边从时间t中取值，被赋值的变量则存在于时间 t + 1 中（且这样的赋值只允许一次）。这就统一了函数式编程和同时模拟时间和状态的“类命令式”编程。

也要提一下 Ashcroft 和 Wadge 设计的 Lucid 语言（编者注：一种数据流语言，用于非冯模型编程），该语言扩展了 Strachey 的许多思想。

另外，数据库中的“原子事务”也值得一看，思想很类似，只是粒度更粗——从来没有破坏什么，也不用竞争条件，新的版本以一种非破坏性的方式创建出来。其中有了版本的历史。

“时间是个好主意”，这是关键的一点——我们想要它，想用安全、合理的方式处理它——而这些方式中绝大部分（如果不是全部的话）都可以是处于稳定世界线状态序列之间的纯函数式事务。

“刚刚计算来的稳定状态”非常有用。它再也不会改变——因此它代表了系统模拟中的一个“版本”——且可以在产生下一个稳定状态的函数式转换中充当源数值。它还可以充当数据源，为那一刻的世界创建视觉效果。历史信息则可用于调试、撤消、回滚等需要。

在这种模型中，“稳定状态之间时间并不存在”：“时钟”只在新状态完成时走表。就程序而言，CPU 本身并不充当时钟。对于具有内在、干净时间模型的确定性关系，这种思想带来一种非常简易的处理方式。

出于很多理由（但没有一个好的）这种维持安全的方法在上世纪60年代输给了在命令式编程中使用竞争条件，然后再通过可怕的、可能导致死锁的信号量来保护它们的做法。

某些时候，任何了解 Lisp 且对对象间的消息传递感兴趣的人都必然“运用”并注意到一种对象（一个 lambda 的“东西”，可以是一个闭包）可以捆绑到一组参数上（看起来有点像消息）。如果一个人知道 Lisp 1.5 是如何基于新式的延迟绑定参数求值来实现的，理解还会更深入。这里指的是 FEXPR，而不是 EXPR——未求值的表达式可作为参数传递，之后再求值。这使得不太优雅的“特殊形式”四处充斥，它们本来可以写成漂亮的惰式函数。

使用前述的时态建模，可以松掉“求值－应用”的耦合，通过安全的消息传递来获得时间层之间的函数式关系。于是，由于我一直喜欢从系统模拟的视角看待计算，我便把“对象”和“函数”看作两种互补的思想，它们并不冲突。

术语一旦成为宗教或更加严格的选择与风格，便会失去它们的意义。这里说的自然是“面向对象”和“函数式编程”这两个术语。我不会将“函数式编程”的一般概念跟任何特定语言等同起来。我坚持认为“函数思想”是一种可靠的映射。类似的，我也不会把“面向对象”的一般概念同任何特定语言等同起来。如今这两个术语被“殖民”了，意思也变了。

还有一个大问题是“对象”和“抽象数据类型”的混淆，以及对“数据”和“赋值语句”的固执。如果真正强化了封装，对象就可以根据需要处理设计参数（包括保存历史信息）。

### 分布式环境中的对象

有朋友问我现在如何理解分布式环境中的对象和系统模拟的，是否依然认为有可能构造一种系统，它既有互联网那样可以有机增长的规模，又有类似于虚拟时间的良好的、可预测的语义？

好问题。这里面有好几组问题及其权衡关系。二十世纪70年代 Dave Reed（编者注：美国计算机科学家，UDP 协议设计者）最初思考的是面向整个互联网的操作系统应具有什么样子。在他提出的许多有趣想法中，其中之一是通过由虚拟时间（pseudo-time）组织起来的分布式克隆计算来处理长延时和海量潜在用户的问题，然后慢速的互联网仅用于输入和偏差同步。这就是我们本世纪00年代早期在 Croquet 中实现的东西，那时互联网上一次典型的、还算不错的 ping 来回大约80到100毫秒。这已经好到可以无需任何服务器而创建《魔兽世界》这样的大规模并行游戏（甚至飞行仿真游戏）了，只要有玩家正在用着的那些机器就够了（分布式）。后来的版本做得更多更全面。

插一句，去掉实时图形和交互的 Croquet 便自动提供了一种分布式的面向对象数据库。虚拟时间是背后的大理念，保护着数据库中的分布式原子事务。

而且多年来人们一直在讨论。它能否实现？需要在哪些领域做多少工作？等等。

我们在 Parc 做过的与对象有关的工作就是 ARPA/Parc 社区中发生的网络思维的一部分，它最终产生了思考更高层网络实体的倾向。“网络层实体”的一个相当不错的、过渡性的实现是 Gerry Popek 在 Parc 花了一年时间思考“网终系统应有的样子”之后，和他在 UCLA 的团队一起完成的 LOCUS 系统。那是建立在异构机器类型之上的一种迁移式的负载平衡思想，与虚拟时间概念形成高度的互补。

我希望看到富有才华的团队把第二个问题再过一篇。对可伸缩规模的适应性很难事先预测，最好实际去实现它。对于虚拟时间，如果你了解它却不使用它，任何情况下我都觉得有点疯狂，而如果不了解它，那就有点业余了。在这两者之间，则是以各种“不二法门”为特征的宗教（而这跟任何科学都背道而驰）。
## 传统应用的 Docker 化迁移

文/ 晏东

>目前，Docker 在互联网企业有着很多应用案例，但在传统企业的应用案例却屈指可数，本文作者根据自己多年的实践经验，总结出了传统应用 Docker 化迁移过程中需要注意的十大事项。

Docker 是云技术和 IT 技术的未来，这一点正在被越来越多的公司认识到，但是对于传统企业来说，如何将传统的应用迁移到 Docker 是一个迫切需要解决的问题。传统企业，尤其是国内的传统企业，IT 建设普遍滞后，当大多数互联网公司都在大面积使用 Docker 的时候，传统企业还在为虚拟化、公有云和敏捷开发挣扎。很多企业都在提工业4.0，但是信息化建设却没有提到一定的高度。企业的信息化程度，很大程度上决定了企业的生产效率，而 Docker 则从应用层面提出了非常好的解决方案。本文也将从迁移的角度来阐述如何在传统企业中使用 Docker。

### 传统应用容器化迁移的思考

对于传统应用来说，使用和不使用 Docker 可能并不能直接给企业带来好处，相反使用中遇到了问题肯定会给企业带来麻烦。那为什么要使用 Docker 呢？Docker 最大的好处是标准化应用交付，当然随之提高了工作效率，并节约了成本，据国外统计，使用 Docker 平均可以提升60%的效率，同时节约40%的成本。我们可以把 Docker 比作一条软件生产线，当你有了这条生产线后，带来的效率提升是质的飞跃。不过，当你在引进这条生产线的时候，肯定会有很多的疑虑，比如：

如何能保证现有生产线到 Docker 的平滑过渡？

如何确保员工能够快速上手？

如何合理利用现有资源，比如数据库、网络等？

如何使用新的服务框架？

如何重新定义软件层的依赖？

如何处理操作系统问题？

如何重新定义软件的生命周期？

### 应用迁移的注意事项

当我们需要迁移一个应用的时候，首先需要了解其当前正在使用的资源有哪些。你需要了解当前系统的拓扑结构，它是迁移的最好参考，传统的单体模式下，很多应用程序运行在一台主机之上，但在微服务体系下，我们更倾向于通过容器来解耦合，实际上，并不是所有系统都适合于解耦合，进程间通讯是必须要考虑的因素，任何一个企业在迁移过程中都不愿意去重新对一个模块进行编码，因为有的程序可能根本就找不到代码。本文结合我们的实际经验阐述传统应用在容器化迁移中需要考虑的一些因素。

第一，操作系统。如果你的应用基于 Windows 系统，并且不打算使用 Linux，可以直接忽略本文（很多应用是可以迁移到 Linux 的，比如 Java、PHP、Python 等）。对于进程来说，它是只工作在 Ring 3 还是工作在 Ring 0-3 是至关重要的，如果进程涉及到内核操作，需要非常小心，因为他可能会引起系统崩溃。我们知道通常 system call 是会从用户态转到内核态，所以基本都会涉及到内核操作。我所说的内核操作是指你自己写了相应的驱动或者内核模块，因为你的 kernel 代码肯定更容易出问题。因此，我们需要了解容器并不是虚拟机，它本身是一个进程，一个受到诸多管控的进程。即使容器里面的内核版本很高，但骨子里都是你的 Host 内核。因此，容器的隔离并不会像虚拟机一样彻底，对于一个虚拟机，即使内核操作引起崩溃，也不会导致其他虚拟机崩溃，但是，容器则会和大家一起崩溃。所以，我们应当尽量通过容器来隔离不涉及内核操作的应用。如果不清楚是否涉及内核，也不用担心，目前95%以上的 Linux 应用都不直接涉及内核操作。一般的Web服务器，后端服务，基本都不涉及内核操作。

第二，CPU。对于单个应用程序，首先需要考虑的是 CPU 问题，需要几个 CPU，需要多强。如果是 CPU 消耗性的程序，要在不影响其他应用情况下，尽可能多的分配 CPU。CPU 一般是稀缺资源，需要结合实际使用的上限值、下限值和均值做规划。最好的方法就是利用 ps、top、htop 等工具进行跟踪，最好能跟踪一个软件运行周期，得到软件的 CPU 上限和下限。CPU 的跟踪结果会左右后续的容器资源限定值。

第三，内存的大小。使用容器的一大目的就是要限定应用的资源使用，因此我们需要获得容器的初始、运行中以及最大内存。这一部分可以通过 vmstat 等工具来获得。需要指出的是，内存和 CPU 都是利用 CGroup 内核技术进行控制的，所以控制的是使用上限，并不是分配以后就专属于某个容器。只不过如果应用使用内存超过了上限，程序会触发 OOM（out of memory），可能会被 Kill 掉，例如你是通过 Tomcat 来封装应用的，由于启动时候需要使用更多内存，可能存在被 Kill的 可能。这些都可以通过 docker log 和系统日志进行查看。

第四，进程模型。随着高级语言的出现，熟悉操作系统进程模型的人越来越少。父进程是什么，子进程是什么，进程树是怎么样的，线程是怎么构建的都需要弄清楚。这有助于理解应用在一台服务器中所处的位置，以及它能带来的影响。这一部分是通过 ps 命令来查看的。

第五，网络部分。应用使用的是 TCP 还是 UDP，使用了哪些端口，同时数据包的大小是怎么样的，网络的上下行负载在什么程度。这些可以通过 tcpdump、 sar 和 netstat 来获得，有了这些才能设计出容器将要使用的网络模型，是桥接、Host、Overlay、自定义还是网络插件，每一种容器网络都有一定的特点，性能和复杂度也各不相同，我们需要选择最合适的模型来进行规划，而不是选择最复杂的。

第六，用户管理及安全。传统应用系统中可能有自己的一套安全体系，比如 ldap、 active directory 等，因此这一部分也需要考虑，而安全还需要考虑证书、防火墙等问题。容器可以有效提升用户管理的效率，我们可以把 ldap 做到容器里面，同时也可以只暴露需要的端口，降低被攻击的可能。

第七，日志处理。传统应用有的可能没日志管理，有的可能使用 syslog 或者 rsyslog，然后通过中心日志服务器来进行日志汇总。有了容器，我们可以借助诸如 Ghostcloud 等第三方平台，集中化收集日志。可以在 daemon 层面，也可以在容器层面来进行收集。有了容器之后，可以很方便地收集全系统日志，如果有一个基于日志的大数据平台，可以在改动很小的情况下做分析。
 
第八，共享存储及数据库。很多传统应用都会使用跨主机的文件服务，比如 NFS、CIFS。当迁移含有这些服务的应用时，需要添加外部挂载卷。对于 MySQL 或者 MongoDB 等数据库，在迁移的时候需要考虑是否将数据持久化进容器，还是通过外部的挂载卷。如果通过外部挂载卷，需要考虑容器的 HA。同时，如果数据库没有办法提供 Linux 平台支持，则肯定不能做迁移，当然如果数据库提供 Linux 下的客户端，你可以将数据库和应用做一次拆分，再做迁移。对于存储和磁盘的跟踪也必须注意，Host 的 RAID 怎么做，是否需要支持动态扩展，应用程序的运行目录大小及层次结构，应用程序的运行时磁盘操作，应用程序的持久化操作以及应用的日志及 Crash Core 都是需要考虑的地方。这一部分，需要一些专业知识，同时借助于 strace 等跟踪工具来进行分析，这将决定后续容器的挂载卷及空间分配，同时也会决定容器文件系统设计方案。

第九，服务发现。传统企业或者应用可能会用到诸如 ESB 的服务总线，但是随着开源技术的出现和微服务架构的兴起，我们完全可以借助于开源项目或者第三方服务来实现，用的比较多的是 consul、etcd 和 ZooKeeper，其中 ZooKeeper 也是使用非常多的高可用中间件，只不过前两者更专注于服务发现，后者是一个通用组件，并不仅针对服务发现。以前企业里面涉及到服务发现，很多时候都需要对微服务的方式进行统一约定，而由于容器本身有一个外部的 daemon 引擎，其服务发现方式可以通过 Registrator 内置到 daemon 里面，跟传统模式也有区别。

第十，持续集成。很多传统应用出现的时候还没有敏捷、DevOps 和 CI/CD，但是随着移动互联网的高速发展，软件的更新越来越频繁，很多时候一个系统需要在一天内部署几十次。通过不断重复的部署和测试，可以极大提高软件的稳定性。Docker 的快速启动和镜像仓库是天生为 CI/CD 设计的，以前我们启动一个虚拟机需要几分钟，而启动容器只需要几秒钟，有了这种能力集群式和并行的持续集成才能成为可能。对于持续集成目前业界没有通用模式，而且每个团队习惯的方式和关注点都不一样，因此存在很多定制的地方，有的以镜像为引导，有的以代码为引导，没有最好，只有最适合团队的方式；同时，持续集成的流程也没有最好的，只有更好的。需要不断在开发过程中优化。以前国内很多企业受一些国外厂商的影响，花巨资购买流程及其复杂的流程软件，其实现在看来并不都适合国内的开发环境。一个简单的例子就是，由于众所周知的原因，国内访问外网的速度就很慢，而现在很多开源项目都放在 GitHub 上，国外很多看似理所当然的事情，并不适合国内环境。
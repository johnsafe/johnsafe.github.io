## 企业级 Docker 镜像仓库的管理和运维

文/张海宁

>容器应用的使用越来越广泛，容器技术突出的优点就是开发运维一体化。通过把应用及其所依赖的软件包、操作系统文件等封装在容器镜像中，使得应用在开发、测试和发布过程中都具有相同的运行环境，带来极大的便利。

从图1这张经典的 Docker 容器状态转换图可以看到，容器镜像（images）的关联箭头最多，不言而喻，镜像就是容器技术的核心所在。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8b868eb06f.png" alt="图1  Docker容器状态转换图" title="图1  Docker容器状态转换图" />

图1  Docker 容器状态转换图

概括地说，容器技术包含一静一动两部分：封装应用的静态镜像（images）和运行应用的动态容器（containers）。相应地，容器的开发运维主要涉及镜像管理和运行时（Runtime）管理两部分。本文主要和大家谈谈容器镜像管理的部分。

容器镜像的管理主要围绕镜像仓库（registry）来进行。在应用的生命周期中，无论开发人员或 CI 系统发布镜像，还是测试人员或运维人员下载镜像，都要通过镜像仓库来完成。镜像仓库可以使用公有的 SaaS 服务，例如 Docker Hub。公有服务的优点是可直接使用，无需自己维护。但考虑到访问效率和镜像安全等方面的原因，大多数公司都建立了自己的私有镜像仓库（Registry），因此也需要有贯穿整个应用生命周期的镜像管理策略。

下文主要介绍在开发运维中的管理容器镜像原理和方法，为了便于说明原理，较多地使用 Harbor 作为例子。Harbor 是由 VMware 中国研发团队负责开发的开源企业级 Registry，可帮助用户迅速搭建企业级的 registry 服务，提供权限控制、镜像同步、中文管理界面等功能。


### 确保镜像内容的一致性


在应用的开发、测试和运行等各个阶段，需要确保都使用同一个应用的镜像。一种做法是在每个阶段都用相同 dockerfile 去生成所需镜像。通常认为，相同的 dockerfile 可以构件出相同的镜像，而实际上却并非如此。例如下面的 dockerfile 部分：

```
FROM ubuntu
RUN apt-get install –y python
ADD app.jar /myapp/app.jar
```

首先，FROM 的基础镜像隐含使用了 latest 版本，在不同时间构建的镜像，可能是不同的版本。即使指明了 ubuntu:14.04 这样的版本号也不保险，因为相同版本的系统可能含有补丁等不尽相同的软件包。

再看 apt-get 这样的命令（类似的还有 curl，wget 等），往往会从互联网上引入第三方的软件包，版本的一致性就更加无从确定了。还有在 ADD 语句中添加到镜像里面的文件 app.jar，取决于构建时的文件版本，也是一个不确定的因素。

从上面的例子可以看到，尽管 docker 镜像的目的是构造不可更改的应用环境，但由于其构建的时候往往具有不确定的输入，相同 dockerfile 生成的镜像未必包含相同的内容。因此，最好的方法还是在不同的环境中始终采用相同的镜像（二进制格式），虽然在传输量上比 dockerfile 要大，但是可以确保镜像的一致性。

### 镜像的传输

很多用户在开发、测试和运维中都使用同一个 Registry 作为镜像仓库，这种方式比较适合小团队或简单的项目。在其他情况下，最好使用多个 Registry 以区分不同的用途和安全控制要求。容器镜像管理的参考流程（如图2所示）。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8bd207ea9d.png" alt="图2  应用镜像的管理流程" title="图2  应用镜像的管理流程" />

图2  应用镜像的管理流程

开发环境的 Registry：主要由开发人员使用，镜像变化频繁。当开发完成后，通过 CI 系统生成稳定镜像，并同步到测试 Registry。

测试环境的 Registry：主要由测试人员使用，镜像保持不变。当测试通过后，镜像推送到准生产环境的 Registry。

准生产环境（Staging）的 Registry：主要由测试和运维人员使用，镜像保持不变。当准生产环境试运行后平稳后，再发布到生产环境的 Registry。

生产环境的 Registry：发布镜像到生产环境的节点运行。

从开发到生产的整个过程中，符合要求的容器镜像会逐步进入下一级的 Registry，最后到达生产系统，从而实现容器镜像的构建-传输-运行（Build-Ship-Run）过程。

Harbor 提供 Registry 之间的镜像自动同步和复制功能，通过配置复制策略，自动化管理镜像传输流程。Harbor 的复制策略启动之后，会比较目标 Registry 和本地源 Registry 在镜像上的差异，并把目标 Registry 缺少的镜像从本地推送过去，使得两个 Registry 实例的镜像完全一致。后续推送到源实例上的镜像，会以增量的形式同步到目标实例上。当在源实例上删除镜像的时候，目标实例上的镜像也会被删除。通过 Harbor 的复制机制，可实现两个或多个 registry 实例之间的镜像同步。

### 镜像的权限控制

在企业中，通常有不同的开发团队来负责不同的应用项目，和源代码分项目管理一样，镜像也需要按照项目来存放和管理。由于项目团队中有不同的成员，如项目经理、产品经理、开发、测试和运维等人员，每种人员使用镜像的需求不同，因此可以根据角色分配相应的权限。

例如，测试人员通常只需要镜像的读权限（pull），开发人员需要读写权限（push/pull），项目经理除了拥有开发人员的权限之外，还可以增加和删除项目成员，设定他们的角色。

在 Harbor Registry 中，每个项目中可有三种角色：项目管理员（project admin）、开发者（developer）和客人（guest）。某些项目，如放在 library 中的公共镜像, 可以允许匿名访问，即用户不用 docker login 也可以访问，这样方便某些场景的使用。在整个系统中，还设有系统管理员，具有维护镜像同步策略、用户增删等权限。

需要指出的是，在不同的环境中，某个成员的角色可以不同。例如，在开发环境的 registry 中，运维人员一般不需要权限（或只需要读权限）；而在生产环境中的 Registry，运维人员就需要有读写权限。


### 大规模镜像发布方式

在实际生产运维的中，往往需要把镜像发布到几十、上百台或更多的集群节点上。这时，单个 Registry 已经无法满足大量节点的下载需求，因此要配置多个 registry 实例做负载均衡。手工维护多个 registry 实例上的镜像，将是十分繁琐的事情。Harbor 支持一主多从的镜像发布模式，可以解决大规模镜像发布的难题。

如图3所示，只要往一台 registry 上发布，镜像就像“仙女散花”般地同步到多个 registry 中。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8bd7d0cc60.png" alt="图3  主从模式的镜像分发" title="图3  主从模式的镜像分发" />

图3  主从模式的镜像分发

如果是地域分布较广的多数据中心或跨云的集群，还可以采用层次型发布方式，如从集团总部同步到省公司，从省公司再同步到市公司（如图4所示）。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8bda4ea6b7.png" alt="图4  多级主从模式的镜像分发" title="图4  多级主从模式的镜像分发" />

图4  多级主从模式的镜像分发

在同步过程中，如果源镜像已删除，Harbor 会自动同步删除远端的镜像。在镜像同步复制的过程中，Harbor 会监控整个复制过程，遇到网络等错误，会自动重试。

同步复制的监控画面如图5所示。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8bdcf4a65a.png" alt="图5  镜像复制策略的监控" title="图5  镜像复制策略的监控" />

图5  镜像复制策略的监控

### 镜像删除和空间回收

Docker 命令没有提供 Registry 镜像删除功能，系统日积月累地运行中，将会产生许多无用的镜像，占用大量存储空间。若要删除镜像并回收空间，需要调用 docker registry API 来完成，非常麻烦。Harbor 提供了可视化的镜像删除界面，可以逻辑删除镜像。在维护状态下可以回收垃圾镜像的空间。


### Registry 高可用性

Registry 高可用性（HA）是多数生产系统需要关心的问题，基本要求就是没有单点故障。通常需要根据允许服务中断的时间，以及可以承受的成本和损失，来确定采用的技术。下面介绍3种不同的高可用参考方案。

一种比较标准的方案，就是多个的 Registry 实例共享同一个后端存储，任何一个实例持久化到存储的镜像，都可被其他实例中读取。通过前置LB进来的请求，可以分流到不同的实例中去处理，实现了负载均衡，也避免了单点故障（如图6所示）。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8be155ee2f.png" alt="图6  用共享存储实现多Registry实例" title="图6  用共享存储实现多Registry实例" />

图6  用共享存储实现多 Registry 实例

应该指出，实际中需要考虑的问题远比上述模型复杂。例如，共享存储的选取，用户 session 在不同的实例上共享等等。用户可根据自己业务要求设计出不同的方案。Harbor 将会推出基于 swift 分布式存储，以及共享 session 的方案（采用 Redis）来满足用户的需求。

如果没有共享存储，可采用第2种方案，就是在两个节点间采用双主复制策略，互相复制镜像。即使有一个实例失效，另一个实例仍然可以提供服务，从而在一定程度上可以满足 HA 的需求。在这种场景下，两个实例的用户数据并没有同步，因此需要分别配置相同的用户账号（如图7所示）。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8be40bd987.png" alt="图7  双主复制实现准HA" title="图7  双主复制实现准HA" />

图7  双主复制实现准 HA

第3中方案是利用已有的高可用平台，例如 vSphere HA，配合分布式存储 VSAN，可以实现 Registry的高可用性, 具体架构如图8所示
。
<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8be6822e33.png" alt="图8  基于VSAN和vSphere搭建高可用Registry架构" title="图8  基于VSAN和vSphere搭建高可用Registry架构" />

图8  基于 VSAN 和 vSphere 搭建高可用 Registry 架构

节点出现故障的时候，有 vSphere 自动切换到好的节点上，镜像数据不丢失（如图9所示）。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f8be8982dc4.png" alt="图9  用VSAN和vSphere实现Registry自动迁移" title="图9  用VSAN和vSphere实现Registry自动迁移" />

图9  用 VSAN 和 vSphere 实现 Registry 自动迁移

### 小结

本文以开源 Harbor Registry 为例子，总结了企业中 Registry 的常见使用场景和要点，希望对大家有所启发。同时也欢迎大家使用 Harbor 和反馈意见，Harbor 的 GitHub 地址为 https://github.com/vmware/harbor 。
## MySQL 数据库读写分离中间件 Atlas

文/朱超

Atlas 是由奇虎360公发的基于 MySQL 协议的数据库中间件产品，它在 MySQL 官方推出的 MySQL-Proxy 0.8.2版本的基础上，修改了若干 Bug，并增加了很多功能特性。目前该产品在360内部得到了广泛应用，覆盖80%以上的 MySQL 业务，每天读写量达数十亿次，于 GitHub 开源后，业界几十家公司将其应用于生产环境。

Atlas 项目源代码托管地址https://github.com/qihoo360/atlas。

### 产品研发背景

该项目最早在2012年提出，主要为了解决两个问题：

一是业务程序员对数据库细节关注过多。在没有中间件的情况下，应用程序直接连接 MySQL 的主从库，需要在配置文件中指定主从库的 IP 和端口，并由业务程序员自行决定将写语句和读语句分别发往主库和从库，在数据量较大的情况下还需要自行管理分库分表等技术细节，使得业务程序员负担较重。

二是 DBA 运维工作不方便。数据库宕机是家常便饭，在需要切换或上下线数据库时，DBA 需要协调业务程序员修改配置，运维操作也会对业务造成一定干扰，影响 DBA 工作顺利进行。

我们希望能将业务与 DB 进行一定程度的隔离，使业务程序员尽量少关心 DB 的细节，可以专注于编写业务逻辑；另一方面 DBA 的运维操作尽量做到对业务无影响。如此则需要将读写分离、分库分表、平滑上下线 DB 等逻辑提炼出来，以公共组件的方式提供给以上两类人群使用。从形式上看有两种，一种是独立的中间件服务，另一种集成于客户端的 LIB。前者优点是升级更新较方便，而且与语言无关，缺点是网络增加一跳，数据需要转发，性能可能不如 LIB 形式，后者优缺点正相反。经过权衡我们选择了前者，除以上考虑外还有部分原因是我们团队与各条业务线是独立的部门，要推动业务工程师升级LIB有相当的困难。

开始时调研了 MySQL 官方的 MySQL-Proxy、阿里巴巴的 Cobar、Amoeba、TDDL 等产品，其中 MySQL-Proxy 更新缓慢，长期停留在 Alpha 版阶段，Cobar 安装部署相对复杂，Amoeba 不支持事务，TDDL 未完整开源。最终我们选择了 MySQL-Proxy 进行二次开发。

### 技术架构

#### 部署架构

Atlas 一般搭配 LVS 使用，客户端通过 LVS 访问 Atlas，以避免单点故障，当然也可以使用 Keepalived 等。Atlas 后面挂接 MySQL 的一主多从集群，需要注意的是主从同步需要 DBA 预先配置好，Atlas 只涉及客户端与 DB 间的网络交互，DB 与 DB 间的通讯与 Atlas 无关。

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c6716257d2b.png" alt="图1  读写分离架构  " title="图1  读写分离架构  " />

图1  读写分离架构

Atlas 会把客户端发来的 SQL 语句根据读写分别路由到主库和从库上，对于有多台从库的情况，还会根据加权负载均衡策略决定选择哪台从库来执行每条读语句。

#### 线程模型

Atlas 的线程模型与 Memcached 相似，都是由一个主线程和若干个工作线程组成。主线程负责监听客户端的新连接，工作线程在系统启动时即创建完成，并监听管道读端的读事件。当有客户端连接到来时，主线程将客户端的 IP 和端口等信息封装成一个 CON 结构，然后选择某个工作线程来处理该客户端的请求。选择的方法可以是 Round-Robin 方式，也可以根据各个线程的负载情况选择负载最轻的线程（可以粗略认为待处理队列最短即为负载最轻）。主线程选定工作线程后，将 CON 结构放入该线程对应的待处理队列，然后向相应管道的写端写入一个字节（字节内容无所谓），则工作线程会收到管道读端的读事件，并从队列中取出 CON 结构，进行下一步处理。当然也可改用 Linux 的新系统调用 eventfd 实现对工作线程的唤醒，性能比管道更高。

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c671a1ac166.png" alt="图2  线程模型" title="图2  线程模型" />

图2  线程模型

### 两个经典技术问题

#### 字符集

MySQL 支持多种字符集，字符集状态与会话（连接）绑定，即各个连接上的字符集互不相干。而 Atlas 拥有连接池，要求实现连接复用，这就不可避免会导致字符集混乱。

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c671dca9d8c.png" alt="图3  访问架构" title="图3  访问架构" />

图3  访问架构

如图3所示，客户端发来 SET NAMES UTF8 语句，Atlas 从连接池里取出一个空闲连接（连接1），在连接1上执行该语句后，将连接1放回连接池。客户端再发来一条 SELECT 语句，Atlas 又从连接池里取出一个空闲连接（连接2），连接2大概率与连接1不是同一个连接，在连接2上执行 SELECT 语句，而连接2并未设置 UTF-8 字符集，因此造成乱码。

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c67203b11d2.png" alt="图4  访问架构" title="图4  访问架构" />

图4  访问架构

解决方案：Atlas 记录每个客户端和每个连接的当前字符集状态（以一个正整数表示即可）并进行相关修正。当客户端发来 SQL 语句时，Atlas 会检查该语句是否要设置字符集（SET NAMES 或 SET CHARACTER_XXX）。如某个客户端发来 SET NAMES UTF8，Atlas 从连接池内取出连接1并执行该语句，执行成功后，将该客户端和连接1的当前字符集均置为 UTF-8。之后该客户端发来 SELECT 语句（或其他非 SET 类语句），Atlas 从连接池内取出连接2，然后比较客户端的当前字符集（上步已设置为 UTF-8）和连接2的当前字符集（假定为 GBK），若一致则直接执行，若不一致则在 SELECT 前插入一条 SET NAMES UTF8，将两条语句一起发给 MySQL，第一条语句起到将连接2的字符集修正为 UTF-8 的作用，然后再执行 SELECT 则不会乱码。当然也可以进一步优化，就是由 Atlas 直接返回 SET 类语句的结果（OK）给客户端，省去一次与 MySQL 的交互过程。

#### 自验证

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c6723adb9d2.png" alt="图5  连接认证" title="图5  连接认证" />

图5  连接认证

图5是 MySQL 的连接认证示意图。

1. Connect 阶段，客户端建立与 MySQL 的 TCP 连接；

2. HandShake 阶段，MySQL 向客户端发送握手包，其中携带多项信息，如服务端的特性标志、字符集等，此处我们主要关心的是其包含的20个字节的随机串；

3. Auth 阶段，客户端将握手包内的随机串取出，与自身的密码一起执行以下运算 SHA1( password) XOR SHA1( "20-bytes random data from server" <concat> SHA1( SHA1( password ) ) )，得到一个加密串，加上客户端的用户名、特性标志、字符集等附加信息，组成认证包发给 MySQL。

4. Auth-Result 阶段，MySQL 通过在 mysql.user 中保存的该用户名对应的密码，也执行同样的运算得到一个加密串，并与认证包中的加密串对比，若相同则认为密码正确，返回结果 OK 给客户端，否则返回 ERR 拒绝连接。

返回 OK 后应用层连接即建立完毕，接下来客户端向 MySQL 发送 SQL 语句，并从 MySQL 接收语句的执行结果，然后再发送下条语句……直至有一方断开连接为止。

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c6727ece6fb.png" alt="图6  Atlas连接访问工作原理" title="图6  Atlas连接访问工作原理" />

图6  Atlas 连接访问工作原理

图6是1.x 版本的 Atlas 的工作过程。

可以看到，在连接认证阶段，Atlas 简单地透传客户端与 MySQL 双方的通讯包。初看似乎并没有问题，但考虑到 Atlas 后面挂接的是一主多从多台 MySQL 时，情况就变得比较复杂。

客户端向 Atlas 建立连接时，Atlas 需要选择转而向哪台 MySQL 建立连接。以最简单的一主一从为例：若 Atlas 向主库建连接，则从库上没有连接，无法实现读写分离；若向从库建连接，则问题更严重，因为主库上没有连接，所以写语句无法执行。那么能不能同时向两台 MySQL 建连接呢？问题在于两台 MySQL 都会发送握手包，而客户端遵循 MySQL 协议，它不可能一次接受两个握手包……

在1.x 中，我们使用了一个取巧的办法，即在主库上预留一定数量的连接，比如32个。客户端向 Atlas 建立连接时，首先检查主库上的连接数是否已经达到32个，若未达到则向主库建连接，若已达到则向从库建连接。这样既保证了写语句可以在主库上执行，又使得读语句可以在从库上执行，从而正确实现读写分离。这个办法有几个潜在的问题：1. 若有多于32个客户端同一瞬间发送写语句，则主库上连接数将不够用，当然也可以让某些客户端阻塞等待其他客户端让出连接来部分解决；2. 无法支持长连接；3. 在主库连接数达到32个之前，仍然无法读写分离。

仔细分析以上情况，可以得知，其本质原因是 Atlas 需要依赖客户端的连接动作转而向 MySQL 建连接，因此能建立连接的数量最大不超过客户端的 Connect 次数，这就极大地制约了 Atlas 作为中间件的灵活性。为了摆脱这一束缚，就要求 Atlas 能自主决定何时、向哪台 MySQL、建立多少个连接。实现该特性的前提是，Atlas 必须知悉客户端的用户名和密码，因为从1.x 的交互图上可知，Atlas 透传客户端的认证包给 MySQL，而认证包内只有加密串而没有密码明文，也不可能反解（否则我们就破解了 MySQL 的加密协议）。

<img src="http://ipad-cms.csdn.net/cms/attachment/201609/57c672a8c988d.png" alt="图7  Atlas 连接访问工作原理" title="图7  Atlas 连接访问工作原理" />

图7  Atlas 连接访问工作原理

图7是2.x 版本 Atlas 的工作过程。

用户名和密码事先已经作为配置在 Atlas 启动时加载进来（当然也可以通过 Atlas 的管理接口进行动态的增删改查）。当客户端来连接 Atlas 时，Atlas 自行产生一个握手包（包含20字节随机串）发给客户端，然后接收客户端发来的认证包，根据配置的用户名和密码进行加密计算并检查结果，根据结果正确与否返回 OK 或 ERR 给客户端，从而完成客户端的连接认证工作。客户端发来 SQL 语句时，Atlas 检查连接池中是否有空闲连接，若有则直接使用，若没有则根据配置的用户名和密码自行向 MySQL 建立新连接，然后供该语句使用。

此方案的优点：真正完全的读写分离，支持长连接，连接按需建立，连接数随并发度上升而增加，随并发度下降而减少（可以依靠 MySQL 的 wait\_timeout，也可以由 Atlas 监控连接的空闲时间）。

### 小结

从以上内容可以看出，MySQL 中间件产品的设计与开发需要对相关协议有比较深入的了解，且因 MySQL 数据库软件自身的升级，协议还可能随之改变。限于篇幅，还有不少功能点不能一一细述，有兴趣者可查阅项目源码托管平台上的资源。
## 谈谈 Unikernel

文/林帆

>Docker 收购当下掌握 Unikernel 社区主导话语权的 Unikernel Systems 公司，从 Docker 创建 libcontainer 成为独立容器引擎，到创建 Swarm 成为独立集群方案，如今 Docker 开始投入真金白银，搅入 Unikernel 这片充满机遇的蓝海，这个举动足以看出 Docker 公司的远见。

### 前言

2016年初，与 Docker 相关的第一条重磅新闻莫过于在1月份 Docker 公司宣布收购刚刚在业界小有名气的微型操作系统公司 Unikernel Systems。然而时至今日，当我们在技术圈内谈及 Unikernel 时，看到的仍然是许多人疑惑的表情。就像“容器”这个怪物刚刚出现在国内的技术社区时那样，到处都显得格格不入。

在 Docker 才诞生时，布道者们通常会拿出一张经典的虚拟机 VS 容器对比图，来讲解容器的好处。那么，在开始今天的话题前，先以图1加上 Unikernel 的对比，镇一下场子。诸位坐好，且听我把容器与 Unikernel 的这点事儿慢慢道来。

<img src="http://ipad-cms.csdn.net/cms/attachment/201604/56fb77571166b.png" alt="图1  虚拟机、容器和Unikernel" title="图1  虚拟机、容器和Unikernel" />

图1  虚拟机、容器和 Unikernel

### Unikernel 是什么

“Unikernel”的概念在早在20世纪90年代时就已经形成雏形，它是一类特殊操作系统的通称，有点像我们现在所说的“容器”或者“Container”，是个概念层面的东西。最早的 Unikernel 操作系统原型是 Exokernel 和 Nemesis，之后相对比较出名的有 Xen 社区主导的 MirageOS、前 KVM 开发者主导的 OSv 以及由 NetBSD 公司开源的 Rump Kernels。

在通用的操作系统中，系统的内核与用户的应用程序之间是有明确分界的，在 Windows 或是 Linux 中都有清晰的“内核态”和“用户态”定义，并通过“系统调用”的方式进行数据交换。这样做的目的是将操作系统和硬件打交道的功能与上层应用隔离，从而屏蔽其底层的差异性和复杂性。而在 Unikernel 操作系统中是没有这种差别的，所有程序与底层的核心驱动都运行在一起，不存在运行时状态上下文切换的额外开销。在国内关于 Unikernel 的一些早期文章中将这种运行方式表述成所有程序都运行在“内核态”，这样的表述并不准确。因为 Unikernel 并没有专门的内核概念，而是将每个应用程序在编译时可以直接指定引入特定的驱动和核心 library，相当于每个程序都是自带操作系统，而且是单独定制裁剪的操作系统。

通过 Unikernel 系统方式构建出来的应用程序都是可以独立发布和直接运行在虚拟化平台上的，由于 Unkernel 系统原生不考虑多用户和多任务的复杂场景，因此可以做得十分精巧。一个应用服务就是一个操作系统，从而形成规模极大的操作系统集群。你可能会说，这不就是嵌入式操作系统么？单纯地从概念上看，Unikernel 与嵌入式系统颇有几分相似，但 Unikernel 系统的运行环境通常是虚拟化的基础设施，而不是那些嵌入式硬件设备，稍后笔者也会对这个关键性差异进行更深入的讲解。

说到这里，有些读者可能开始嘀咕了。在本篇开始时说到被 Docker 收购的那个“Unikernel Systems”与我们说所的“Unikernel”是同一个东西么？

其实不是。

被 Docker 收购的“Unikernel Systems”是一个由许多专注于 Unikernel 技术的极客们组成的，致力于推广和发展专用 Unikernel 产品的公司，总部在英国。两者的关系在于，Unikernel Systems 公司（只有13名正式员工）同时也是 Unikernel 社区目前最主要的贡献者。Unikernel 组织的官方网站是“unikernel.org”，而 Unikernel Systems 公司的官方网站是“unikernel.com”，从两者的网站风格上同样能看出千丝万缕的联系。

<img src="http://ipad-cms.csdn.net/cms/attachment/201604/56fb7761df570.png" alt="图2  Unikernel Systems公司网站（上）和Unikernel社区网站（下）" title="图2  Unikernel Systems公司网站（上）和Unikernel社区网站（下）" />

图2  Unikernel Systems 公司网站（上）和 Unikernel 社区网站（下）

那么，作为一种操作系统，Unikernel 与我们所熟知的 Docker、Linux 或者 Windows 有什么样的关系呢？

简单的回答是，没有必然关系，但它们之间可以有交集。通常来说，Unikernel 操作系统既不能兼容 Linux 或 Windows 软件，也不能运行 Docker 容器（目前还没有能运行 Docker 的 Unikernel 系统）。但凡事不会是绝对的，开源界总会有一些别具一格的例外（比如稍后会介绍的 Rump Kernels 和 OSv），正是这些例外的出现，使得已经沉闷许久的 Unikernel 如今得以驾上容器化的大浪，与 Docker 有了这次亲密的约会。

### Unikernel 的诞生与发展

Unikernel 的前身是 libOS。这个概念源于当时嵌入式操作系统架构的一次研究性的尝试，它将操作系统应用于各种硬件设备的驱动进行抽象，形成了各种不同的、可替换的 library，这与 Linux 系统最初的发展有些相似。然而这些创造者们走了一条与 Linux 内核不同的发展路线，他们没有将驱动与系统代码进行进一步的封装和整合而形成“内核”，更没有使用诸如“内核态”与“用户态”的划分，而是让使用系统的用户以及开发者们直接与驱动通信，只需要在编译时引入适当的 library，便能构建出快速适应不同硬件设施的应用服务。

随着 libOS 的发展，出现了许多各立门户的操作系统分支，这些系统通常都只会具备有用于特定硬件的专属驱动。由于开发者自身的喜好和偏向性，各系统对不同硬件的支持差异较大。而同一时期诞生的以 Unix 和 Linux 为代表的另一操作系统门派，凭借着更好的易用性和统一性逐渐占据了主导地位，这个门派也就是现在大家所熟悉的大而全的系统内核，多用户、多任务，加上严格的内核与用户分界的操作系统风格（要是当年胜出的是 libOS，整个计算机行业的发展路线也许就完全不一样啦）。

值得庆幸的是，在 libOS 并未完全没落之前还发生了一件事情，那就是虚拟化技术的兴起。随着虚拟化的广泛应用，一些 libOS 系统也开始提供用于虚拟化基础设施的 library 驱动。正在 libOS 逐渐势弱之际，当时的虚拟机化新秀 Xen 发布了一个独立的社区操作系统项目：MirageOS。这个项目是一个基于 libOS 理念设计的开源操作系统，但它比其他的 libOS 系统更进一步之处是，索性直接抛弃了所有物理硬件的驱动支持，专心一致做虚拟化，而将硬件的差异统统交给虚拟化平台去完成。同时，MirageOS 借着 Xen 虚拟化的广泛应用，打出了所谓“Cloud Operating Systems”的大旗（因为 MirageOS 也就只能运行在虚拟化的云平台上），并将同一时期诞生的这类 libOS 操作系统都统称为“Unikernel”。

在 MirageOS 之后，Unikernel 的叫法就被沿用下来了。此后还陆续诞生过许多基于这种设计理念的操作系统，例如：ClickOS、Clive、HaLVM、LING、Rump Kernels 和 OSv 等。接下来我们要特别介绍最后的两种，因为它们在 Unikernel 系统的发展过程中具有十分独特的地位。

### Unikernel 的兼容性探索

在 Unikernel 不断演进的过程中，分化出许多不同的发展方向，有些带有浓厚的学术色彩，有些则充满创造性或实用性。其中值得一说的是 Rump Kernels 和 OSv，这两个项目是 Unikernel 对现有系统软件的兼容性改善方面做出的十分有价值的尝试。

前面介绍 MirageOS 时，并没有提到 MirageOS 系统是用一门自己独有的语言编写的，这个语言叫做“OCaml”。作为典型的 Unikernel 程序运行方式，用户也必须通过 OCaml 编写自己的程序，这样才能在编译时打包成运行的内置操作系统的软件。从设计上来说，OCaml 是理念十分先进的函数式编程语言，然而由于这门语言的受众量有限，软件移植困难，注定了 MirageOS 操作系统在这个大局已定的服务器系统领域很难再有大的作为。

吸取了前人的教训，Rump Kernels 和 OSv 在设计时，分别通过各自的方式对现有的主流软件体系进行兼容。

Rump Kernels 的思路干脆明了，Unikernel 的架构针对的就是大规模的虚拟化服务器应用，既然 POSIX/Linux 是服务器软件的主流标准，那就兼容这套标准吧。Rump Kernels 系统核心使用 C 语言开发，提供 POSIX 相关的各类 library，以及符合 POSIX 标准的 C/C++ 编译器，又原生编译了包括 Python、Ruby、PHP、Bash、Node.js、Rust 等诸多语言的解释器和编译工具。这样一来几乎绝大多数能在 Linux 上使用的软件都可以快速迁移到 Rump Kernels 上了。

OSv 系统同样是使用 C 语言编写的，不过它要稍微任性一些，因为 OSv 的 C 编译器并不兼容 Linux 的 POSIX/GCC 标准。即便如此，许多标准的 C 语言应用（没有用到 POSIX/GCC 编译器特殊语法）都是可以直接在 OSv 编译运行的。此外，OSv 的高明之处在于，它成功地移植了 Java 虚拟机（这是 Rump Kernels 都没有做到的），这个在 TIOBE 编程语言流行度排行长居第一位的语言的确为 OSv 系统留住了不少用户。此外，OSv 及时跟进地提供了包括 Tomcat、Cassandra、Redis 等一些主流标准服务的官方操作系统，省去了用户自行编译的麻烦。

注意，我说的是“Tomcat 的操作系统”、“Redis 的操作系统”，这种说法未必准确（应该叫“内置操作系统的 Tomcat 服务”等），但值得强调的是，这些服务都是会直接运行到虚拟化硬件上的。每个服务就是一个内置操作系统的整体，这就是 Unikernel！ 服务与系统的边界已不存在，成为完全的单体，这种转变得让才刚刚适应容器的开发者们稍微消化一会儿。

### Unikernel 带来了什么

Unikernel 的优势概括起来就是：架构简单、安全高效。

首先，Unikernel 抹去了现代操作系统由于软件层级抽象而导致的复杂性。越是通用的操作系统（比如 Linux 或 Windows）包含了越多对特定的应用而言并不必要的服务、驱动、依赖包等。譬如 USB 驱动这类东西在虚拟化的云环境中其实是无用的，但在内核运行时仍然会去将它加载进来。这些多余的内容既为软件运行增添了负担，又额外消耗了非必须的资源。

其次，Unikernel 消除了运行时内核态与用户态切换的过程。Unikernel 的核心驱动与应用程序是同时打包构建的，其内存是单地址空间（Single Address Space），不区分系统内核区域和应用服务区域，因此不论是在启动速度或程序执行效率上都远高于通用的服务器操作系统。通常一个 Unikernel 系统的启动时间都在几十毫秒左右，可以这么说，只需一眨眼功夫，成千上万个服务节点的集群就启动就绪了。

此外，Unikernel 带来的还有安全性方面的提升。一方面，只运行操作系统的核心，抛掉那些可能是漏洞来源的视频、USB驱动、系统进程极大地减小了可攻击的面积。另一方面，对于 Unikernel 而言，每一个操作系统都是定制用途的，其中包含的核心库均不相同，即使某个服务构建的操作系统由于特定软件问题而遭到入侵，同样的入侵手段在其他的服务中往往不能生效。这无形中增加了攻击者利用系统漏洞的成本。

最后，Unikernel 也是一种不可变的基础设施（Immutable Infrastructure）。不可变的基础设施的构想是 Chad Fowler 于2013年提出的，并随着 Docker 的流行而为人们熟知。

Unikernel 系统一旦编译完整就不可改变，想要对其中的内容进行重新定制的唯一办法就是修改源码然后重新编译。这种软件实施方式有点像使用一次性产品，即安装一次，不做修改，用过即扔。这种方式对保障软件部署的一致性，提高运维效率和降低管理的复杂性方面带来的好处已经被许多容器化的实践所证明。

### 容器式的操作系统

与 Unikernel 操作系统具有异曲同工之妙的还有另一类操作系统，我们暂且称它们为“容器式的操作系统”（Containered OS），典型的代表是 Hyper 和 RacherOS。容器式的操作系统是一种通过容器技术将应用程序直接运行在虚拟化平台上的手段，如果将这类操作系统的运行模式画到开篇的那张对比图里面，得到的结果会与最右边的 Unikernel 如出一辙。

然而这些系统并不是严格意义上的 Unikernel。其中的关键差别在于，容器式的系统依然存在单独的内核概念。以 Hyper 为例，这是一种支持将 Docker 镜像中的内容直接部署到 KVM 或 Xen 虚拟化平台上的工具，当用户启动 Hyper 的操作系统实例时，实际上是启动了一个经过高度精简过的 Linux 系统内核：Hyperkernel。这个内核的启动开销几乎可以小到忽略不计（小于1秒钟），启动后加载一个 Docker 镜像并运行其中的内容，因此同样做到了每个服务独立使用一个操作系统，又使得这个操作系统中有且只有运行该服务所必需的文件和 library，也做到了每个服务的运行环境高度定制化。唯一美中不足的是，这些系统依然保留了 Linux“内核态”和“用户态”的切换（虽然相比普通 Linux 内核，已经要高效得多）。

容器式的操作系统是近年来伴随着 Docker 的繁荣发展而出现的新事物，它是容器技术在 Unikernel 方向上的一种中间状态产物。因而同时具备有两者的优势：Docker 完美的 Linux 兼容性和 Unikernel 的安全和高效。这个刚刚兴起的独立领域同样是符合当下技术演进方向、值得关注的一种趋势。

### Unikernel 与 Docker

回到文章最前面的话题，Docker 收购当下掌握 Unikernel 社区主导话语权的 Unikernel Systems 公司。可是 Docker 与 Unikernel 之间到底有什么可以合作的呢？

这个问题其实在2015年巴塞罗纳的 DockerConEU 已经有了一部分的答案：用 Docker 来构建 Unikernel 系统。

在 Unikernel 巨大的性能和安全性优势的背后是其系统构建的繁琐，每次软件的发布都需要经过“编写应用程序”、“选择需要的 library”、“将应用程序与系统编译到一起形成系统”这些复杂的重复操作涉及到许多构建过程中需要的工具和零散的文件。确保每一个开发者都能获取一套可以正确编译出“某个服务的操作系统”的环境其实是一件比较麻烦的事情，而这个事情正是 Docker 所擅长的。

DockerConEU 2015大会的最后一天，Docker 邀请了 Unikernel 社区成员 Justin Cormack 上台演示了一段使用 Docker 快速构建 Unikernel 系统的 Demo（Justin 也是 Unikernel Systems 公司员工，当时 Docker 还未收购 Unikernel Systems）。这次演示所使用的 Unikernel 正是 Rump Kernels，通过使用 Docker 镜像，Justin 于几分钟内在一个普通的 Ubuntu 主机上创造出构建 Unikernel 系统的环境，并编译出一个内置操作系统的 Nginx 服务，以及一个内置操作系统的 MySQL 服务和一个内置操作系统 PHP 服务，然后在 KVM 上将这些 Unikernel 服务运行起来，最终展示出一个完全运行在 Unikernel 的 Nibbleblog 博客（一个类似 WordPress 的使用 PHP 编写的博客程序）。

更让人惊叹的事情在于，最终编译出来的内置操作系统的 Nginx 服务只有 2MB 大小！这几乎就是一个 Nginx 二进制文件的体积，而它其实是一个可以直接运行在 KVM 或 Xen 这样的云平台上的完整操作系统。

这个答案也许还只是 Docker 的 Unikernel 计划中微不足道的一步，未来的 Unikernel 系统会成为容器技术在操作系统领域的延伸吗？收购 Unikernel Systems 更大的意义在于其背后的 Unikernel 社区，独享 Unikernel.org 和 Unikernel.com 这两个域名可谓是占尽先机了吧。

从 Docker 创建 libcontainer 成为独立容器引擎，到创建 Swarm 成为独立集群方案，如今 Docker 开始投入真金白银，搅入 Unikernel 这片充满机遇的蓝海，这个举动足以看出 Docker 公司的远见。随着容器和虚拟机后技术的进一步融合，这盘棋还大有看头。
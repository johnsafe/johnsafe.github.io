## 人人车 Android 路由机制解析

文/冯宇飞

>界面跳转是 App 的基本功能和需求。随着 App 功能迭代，跳转逻辑也会随之呈几何级增长，相关辅助逻辑则会呈现碎片化分布趋势，最终导致结构失控。因此有必要对跳转进行封装，实现归一化控制。鉴于跳转是全局渗透性行为，常规的模块封装方式难以满足这种特性，框架化是更好的选择。本文详细介绍了人人车 Android 客户端当前使用的界面跳转框架。

人人车成立于2014年4月，Android App 第一版于2015年1月发布。纵观其发展历程，是一个随着人人车公司业务类型丰富和规模飙升而不断进行结构性演化的过程，逐渐实现从功能级到模块级，再到框架级的进化。Android 平台本身的细节和特性被封装进模块和框架，基于其上的业务逻辑变得更为纯粹和通用。

本文全面介绍了人人车 Android App 目前所使用的界面级跳转框架：路由机制，该机制封装了 Android 本身的跳转行为，结合 Uri 实现了独立的界面跳转层，并且具有相对良好的扩展性。

### 为什么要引入路由机制？

对于 Android App 而言，“进入某个界面”一定是极为频繁和基础的功能，而该功能的具体实现方式，按照 Android 的界面组件体系必然脱不开 Activity/Fragment/ View 这几个组件（三者扮演的角色和定位都不一样，但从开发者的角度看，可以简单视为这三者构成 Android 的界面组件体系）：

1.  Activity，startActivity()来进行启动；

2. Fragment，commit 一个 add 和 show 的 FragmentTransaction；

3. View，setVisibility()即可。

上面罗列的几种实现方式，本身没有任何问题，也非常简单，任何一个 Android 开发者都会写成百上千遍来实现“进入某个界面”。

一个基本的问题是：App 本身的存在意义是实现某类业务，业务的实现必然以代码为载体，而业务逻辑中必然会有这样的逻辑“如果条件 A 满足，那么需要进入界面 B”（很简单的需求，对任何一个 Android 开发来说都是小菜一碟），按照上面的分析，“打开界面 B”必然会调用上面罗列的那些 Android API 函数，问题这个时候已经很明确了：业务逻辑的实现代码会和 Android 平台特定的 API 调用代码混在一起，但一个业务逻辑模块不需要也不应该了解底层平台细节（在这里就是 Android 平台），也就是业务和底层产生了耦合。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f898801db88.png" alt="图1  底层解耦示意图" title="图1  底层解耦示意图" />

图1  底层解耦示意图

图1代表了目前一种比较新的（注意，新是相对 Android 而言，因为底层解耦这种理念很早就有）Android 开发设计理念（具体可以参见http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/），即业务逻辑不应该知道外面是 Android 世界，业务逻辑的所有代码不应该有任何和 Android 平台本身相关的部分甚至是平台某些特性引起的特殊业务流程，这样带来的好处很明显：

1. 业务逻辑变得纯粹和清晰；

2. 单元测试不用再考虑环境依赖问题；

3. 开发人员之间的角色分工会更加容易；

4. 业务或者界面的具体实现发生变化时产生的影响被限制在本域内。

实现这个构想也很简单，经典的套路，引入一个中间层，该中间层按需求对业务逻辑开放若干操作接口，进而屏蔽外部平台的细节。

回到刚才提出的问题，对于“进入某个界面”这种功能，如上分析，其具体实现必然不能放在业务逻辑中，需要一个中间层来做这种“脏活”，而业务逻辑只需要心安理得地享用中间层的劳动成果即可。

理论已经有了，但是过于简单，因此具体实现才是本文的重点，毕竟这种理念本身已经不新鲜也过于抽象，而怎么在 Android 中比较优雅地实践这种理论才值得探讨，理论和实践同等重要。

目前我已知的实现方式有三种：

1. 构建一个超级接口，该接口提供了进入每个界面的接口，然后实现即可；

2. “进入某个界面”这种意向被视为触发某种事件，有一个专门的事件处理器来处理，根据事件携带的标识来真正执行进入界面的操作；

3. 将“进入某个界面”这种行为封装为对象，在需要时按需构建并以命令模式的方式运行对象方法即可。

上面介绍的几种实现方式，其本质完全一样，毕竟基于相同的理念，甚至本文要介绍的路由机制，究其本源，也相同，能比较的，也只有扩展性和易用性。

1. 对方法1而言，超级接口本身就是一个设计上的坏味，当然，可以考虑将接口再进行拆分，但拆分以后，将不能很好地适应变化，复用性也比较差，并且“进入某个界面”这种行为应该有一个全部掌控者，因为在业务逻辑中，界面之间的任意跳转完全有可能。

2. 方法2要比方法1优雅，因为它用一种事件代替了无穷无尽的接口，界面的不同体现在事件携带信息的不同上，不过这种方法的缺陷在于事件的投递和消费是一次性的，而 Android 因为界面组件体系的原因，会有一部分异步操作，在这部分操作进行时，相应的事件已经消失，无法再进行下去。

3. 方法3本质和方法2一样，区别在于一个将跳转的实现放在了零碎对象中，另一个则将跳转的实现放在了事件处理器中，缺陷也基本一致。

路由机制吸收了上面三者的设计理念，以路由为指导思路进行设计，算是一种还不错的改良版本。

除了上述原因外，路由机制的引入还有几个原因：

1. 推送到特定界面的需求在不断增长。在推送信息中，标记界面和附加信息的载体是 Uri，并且推送也渐渐不局限于我们现在使用的第三方平台，从短信/网页推送跳转也加入到需求中，这就要求原先处理第三方推送的逻辑要提升为一个全局的路由机制。

2. 为了解决跳转行为本身会造成大量重复代码的问题。之前的实现中，每一个跳转行为都会有类似的逻辑代码，急需整合。

3. 为了解决跳转前置和后置行为实现困难的问题。比如在某种条件下，进入界面 A 要求前置进入界面 B，如果这种逻辑没有一个体系支撑，则很容易把代码结构和逻辑搞得一团糟， 后置行为同理。

4. 为了缓解行为统计的实现压力。会有这样的统计需求，从按钮 A 进入界面 B 和从按钮 C 进入界面 B，要求界面 B 的后面都要上传标记来源（A 或者 B）的统计参数，这种跨组件的信息传递非常折磨人，也会造成丑陋和不明所以的“迷之代码”。

#### 路由机制总体架构和流程分析

首先解释为何“进入某个界面”能和路由联系在一起，将 App 的每个界面都想象为一个路由节点，那么“进入某个界面”自然就是路由到该点，只不过这里“路由”的实际行为是打开 Android 的某个类型界面。

既然每个界面对应一个路由节点，那么自然界面的标识就是 Uri，赋予其一个特殊的 scheme 来代表这是 App 内部的路由节点。采用 Uri 有着天然的通用性，因为 Uri 本身的设计理念便是统一标记所有的资源。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f89b822f1e9.png" alt="图2  路由机制总体架构图" title="图2  路由机制总体架构图" />

图2  路由机制总体架构图

路由机制的总体架构如图2所示：

1.  Router Center 作为一个全局独立服务被使用，任何的模块要进行跳转只需向 Router Center 发起一次携带了必要信息（如 Uri， 目前还引入了标记来源的参数，不过该参数没有并入到 Uri 中，作为单独参数存在）的路由请求即可。

2. Router Center 内部会维护一批路由策略（Routing Policy），以及对路由请求信息进行预处理的 Router Processor（体量小，因此图上未标出）。策略会根据路由请求信息进行第一级路由，定位到某个 Activity 上，如果该 Activity 本身已是终点，则到此结束，路由请求会被删除。

3. 如果本次路由终点是 Activity 中的某个 Fragment 或者 View，路由策略则无能为力，这是因为 Android 本身的特性：路由策略可以通过 startActivity 来启动某个 Activity，但是该 Activity 真正启动就绪需要时间，并非一个同步的过程，路由策略不可能在 startActivity 之后直接进行操作 Activity 内部 Fragment 或者 View 的操作，因此路由策略的一级路由就止步于 Activity 层。后面的二级路由就交由 Router 进行，这里的 Router 类似于第一章介绍的方法3的行为对象，不过这里 Router 的调用是被动的，Activity 会在合适的时机自动调用 Router 的路由方法，此时，Activity 必然已经启动就绪，所以进行二级路由安全有效，Router 将所有细节封装在内部，外界唯一能调用的只是 Router 的一个无参函数，单纯将其“驱动起来”，因为本次路由请求没有结束，所以之前发起的路由请求还会保存在 Router Center 中，还可被 Router 拿到进行下一步路由，这也解决了前一节方法2的缺陷，即跳转行为信息的保存。

4. Router 在拿到当前进行中的路由信息后，按照自己的内部逻辑进行二级路由到 Fragment 或 View。而如果有信息在整个过程中需要透传，因为 Router Center 维护了这份信息，因此不必再写一堆在 Activity 到 Fragment 之间穿信息的逻辑。

5. 图2为了便于表达，只在 Activity 中显示了 Router，但是真正实现中，Fragment 也可以有自己的 Router，究其原因，和3分析的类似，因为 Fragment 的“启动”就绪，也不是一个同步的过程（当然，有强制将其变成同步的 API，但是我们不能以此作为通常情况），因此 Fragment 也会在一个合适的时间点回调 Router，完成“三级路由”。

上面讲到的 Activity 和 Fragment 会在合适的时间点回调 Router，是基于 Android 的生命周期机制。路由策略会启动 Activity，根据 launchMode 的不同，Activity 有两个必经的回调点：

1. 如果新构建一个 Activity，则 onCreate()被回调；

2. 如果重用当前存在的 Activity 栈内的 Activity（比如 SingleTop 等），那么 onNewInent()必然被回调。

最关键的是上面两者互斥，并且这两个都是安全的时间点，可以进行 Fragment 或者 View 操作，因此，路由机制会要求 Activity 在这两个时间点回调自己的 Router。

而对于 Fragment，上面 Activity 的两种操作都会触发 Fragment 的 onResume()回调，而它则代表 Fragment 马上可见（其实这个表述不精准，但是在这里足矣），这也是 Fragment 的安全时间点，可以进行 View 或者自身的一些操作。

这样通过路由策略的一次主动和 Router 数次被动路由，最终，App 会被切换到 Uri 所标记的界面上，并且在整个过程中，当前路由信息都会被保存在全局 Router Center 中，不必考虑信息如何在各个组件之间的透传。

本次路由结束后，Router 或者路由策略会调用 Router Center 的 finishCurrentRoute()，并且自动开始下一条路由请求，这就能部分解决前文谈到的界面跳转后置行为问题，尤其便于跳转界面 A 后再跳转界面 B。

还有一点，Uri 的含义完全可以不局限于界面，也可以代表某种行为（或者通过 Uri 附加的 Query 参数来标记某种行为）， 只要这种行为可以通过 Uri 所携带的信息表现出来即可。

以上基本是路由机制的总体架构和流程介绍，其本身属于轻量级体制，也依赖 Android 的某些特性和 API，正是前一节提出的中间层的职责，填平具体平台和业务逻辑之间的鸿沟。

### 路由机制模块具体分析

#### 路由策略模块

该模块承载了全部的一级路由策略，策略本身以对象形式存在和组合，进而实现策略的复用和可插拔，有着良好的扩展性。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f89bfb1289d.png" alt="图3  路由策略模块结构图" title="图3  路由策略模块结构图" />

图3  路由策略模块结构图

如图3所示，路由策略分为两大类：

1. Uri 结构化路由策略。该部分路由严格按照 Uri 规范的 Scheme/Authority/Path 进行拆分，每个路由策略，只能对应这三者的某一个（其实为了精确匹配，因为 Path 可能会有/A/B/C 这种多级出现，Path 级别的路由策略被限定为只能对应某一级 Path， 如/A/B/C 需要三个 Path 路由策略对应），Initial 路由策略比较特殊，其不属于 Uri 结构体系，只是作为一个起点按照 Uri 的 Scheme 下发到不同 Scheme 路由策略，因为 Uri 的结构，这些路由策略全部会按照约定的规则以 Uri 的结构组合在一起，最终形成一棵路由策略树，每个传入的 Uri，会按照 Uri 规范进行拆分，然后按照顺序以 Uri 的每一部分作为 key 快速得到对应这一级的路由策略，再继续向下。

2. 扩展路由策略。扩展路由策略的应用场景是针对那些结构化路由策略不能很好匹配，或者匹配有很大难度的路由请求。例如，有一个特殊的路由策略，要求对能够正则匹配“<http://[^3]/car/[1234]>”的 Uri 进行某种操作，上面的结构化路由策略显然很难完成，这就是扩展路由策略登场的时候，它可以把传入的 Uri 当成一个字符串来操作，做正则匹配自然就很简单，满足了需求。

从组织形式上讲，扩展路由策略的组织形式是列表，而结构化路由策略的组织方式则是树，两者是互补关系，一般的正常路由请求，使用结构化路由策略，可以做到快速定位，并且复用性也很高。扩展路由策略更像是提供了 fallback 方案，并且基于这个特点，扩展路由策略的优先级要比结构化路由策略高。

#### Router 模块
Router 模块前面已经说过其角色定位，承担了路由策略驱动的一级路由下放之后的次级路由，本身以被动式触发进行工作。也体现了一定的封装思想，毕竟调用者确实不应该知道 Router 到底做了什么。下面先简单比较常规方法和 Router。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f89ec30ffea.png" alt="图4  常规的界面显示流程" title="图4  常规的界面显示流程" />

图4  常规的界面显示流程

图4描述的是常规 Android 想要触发一次到 View 界别的显示流程，其中黄色虚线箭头代表的就是之前说过的 Android 启动 Activity/Fragment 之后的异步流程，常规的实现手段无非就是将控制信息层层透传，每一级根据控制信息进行相应的操作，然后再进一步透传信息到下一级，造成的问题很明显：

1. 实现麻烦，从图上可以看出，Activity/Fragment 传递信息的方式不同，这意味传递信息本身很难做成一个归一化操作，而代码中将充斥这些方法。

2. 对于控制信息的处理和再传递，完全耦合在 Activity/Fragment 的代码中，增加了代码的混乱和耦合度。虽然图上没有标出，但是业务逻辑其实参与了整个流程，这非常糟糕。

3. 扩展性差，每增一个新的控制策略，所有的入口处理信息逻辑都要做相应修改。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f89ef97e26c.png" alt="图5  次级路由驱动的界面显示流程" title="图5  次级路由驱动的界面显示流程" />

图5  次级路由驱动的界面显示流程

图5展示了 Router 次级路由的具体运作，大概的流程之前已经说过，这里只说一些关键比对点：

1. 控制（路由）信息不再需要透传，因为 Router Center 在本次路由结束之前会一直保留，而每一级都有 Router 自动去取路由信息，这个功能细节完全在路由机制内部，Activity/Fragment 根本无需知道，通过封装解绑耦合。

2. 为了更近一步的功能封装和拆分，引入 Navigator，如其名，其内部包装了真正在这一层进入某个界面（导航）的功能，Router 到时候只需要按照路由请求调用 Navigator 的导航方法即可，而 Navigator 本身，又可以被 Activity/Fragment 使用，因为导航是一个通用功能，借着路由机制改变的机会，将导航逻辑抽离出来。不过对于单层的界面 Activity/Fragment，可以没有 Navigator，这也是其图例上边框为虚线的原因。

3. 扩展比较方便，所有的改变都被控制在 Router 内部，而 Router 将来也会考虑其复用性。

### 路由机制带来的收益

举一个使用路由机制代替现有流程的例子，不过该例本身并不能算完全基于路由机制，也有部分其他改造，但这部分改造能够生效也得益于路由机制提供的便利。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f89f3dbf763.png" alt="图6  常规的界面跳转时序" title="图6  常规的界面跳转时序" />

图6  常规的界面跳转时序

图6描述的是一个 App 很常见的场景：

1. 业务逻辑视图进入界面 A；

2. 界面 A 的前置条件是需要已经登录；

3. 当前没有登录时，需要前置进入登录界面；

4. 界面登录成功后，返回到业务逻辑，业务逻辑根据返回时提供的标识，得知本次登录成功以后需要进入界面 A；

5. 真正进入界面 A。

以上的流程在真正的实现中有几个弊端和麻烦：

1. 业务逻辑自己需要判断界面 A 是否需要进行前置登录判定，而从封装和分离的角度讲，这个细节完全不应该暴露到业务逻辑中，这部分判定需要一个中心来进行控制和封装。

2. 业务逻辑在发现需要前置登录后，需要自己启动登录界面，并且要传入标记信息以在登录返回后根据标记信息再打开某个特定界面，标记信息本身是需要的，但是这种常规做法很容易引起标记的混乱和零碎，同样缺乏中心控制节点，而且这个过程同样需要业务逻辑亲力亲为。

3. 如果在进入 A 时还要求带入某些信息，这部分信息因为上面的前置登录引起的异步延迟，需要进行保存，琐碎的保存工作也由业务逻辑承担。

4. 最后的登录返回标识检查和进入界面 A 同样需要业务逻辑参与。

总结而言，常规流程最大问题就是前文提到的：业务逻辑参与了过多细节，而且登录标记和前置登录判断需要一个集中控制点。

<img src="http://ipad-cms.csdn.net/cms/attachment/201610/57f89f9d37c53.png" alt="图7  基于路由机制的界面跳转时序" title="图7  基于路由机制的界面跳转时序" />

图7  基于路由机制的界面跳转时序

下面展示的是基于路由机制改进后的流程（如图7所示）：

1. 业务逻辑发起一次到界面 A 的路由请求；

2. Router Center 内部一个模块检查 A 是否需要前置登录；

3. 如果需要登录，则 Router Center 会自动发起一次到登录界面的路由，并且将之前到界面 A 的路由请求的 Uri 以 Uri 请求参数（RedirectUri）的方式附加在到登录界面路由的 Uri 上。这个 Uri 会被登录模块自己保存；

4. 登录模块在登录成功后，会自动检查之前保存的 RedirectUri（到界面 A），然后以该 Uri 为终点发起一次新的路由请求；

5. Router Center 路由到 A 界面。

上述流程简化了业务逻辑的参与度，所有的琐碎细节都由 Router Center 一手包办。基于路由机制提供的 Uri 为标记进行路由的方式，RedirectUri 这种保存下一步启动界面信息的方式也得以生效，并且更为简便，扩展性也不错，可以满足绝大多数的情况。

简单总结路由机制带来的收益：

1. 业务逻辑和具体平台实现解耦；

2. Router Center 维护的路由请求信息简化了原来的信息传递和保存流程；

3. Router Center 作为一个服务可以满足各方面的导航需求，不再局限于推送；

4. 路由策略控制颗粒度更细，并且控制手段也更灵活，复用性更高；

5. 对导航至某个界面这种行为有一个中心节点可以实施切面级控制；

6. 路由机制在实现时不依赖于某个 Activity，直接使用 Application，最大限度地保证了发起路由请求时的灵活和便利。

### 结语

以上即为路由机制的分析，诚然该机制本身还有很多缺陷，比如对 Activity 的控制粒度不够，Uri 不能携带过于复杂的信息，Router 内部的实现没有统一的规范等，而这些也正是后期可以打磨的地方。不过该机制确实简化了一些原来的复杂逻辑代码，也保证了不错的扩展性，可以作为一个方向进行延伸扩展。